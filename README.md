# SE-Lab-HW5

# بخش اول: اجرای Profiling روی JavaCup و بهبود آن

در این بخش، ابتدا عملیات **Profiling** را با استفاده از **YourKit** روی کلاس `JavaCup` انجام می‌دهیم. سپس **snapshot** این اجرا را ذخیره کرده و بررسی می‌کنیم. همانطور که در تصاویر زیر قابل مشاهده است، در ۳ نقطه **hot spot** داریم که نقاطی هستند که مصرف منابع در آن‌ها به طور غیرعادی بالا است. با ریز شدن روی این ۳ نقطه می‌بینیم که هر سه‌ی‌ آن‌ها حین اجرای تابع `temp` رخ داده‌اند:

![Screenshot 2024-12-06 at 11.49.01 AM](Screenshot%202024-12-06%20at%2011.49.01%20AM.png)
![Screenshot 2024-12-06 at 11.49.47 AM](Screenshot%202024-12-06%20at%2011.49.47%20AM.png)
![Screenshot 2024-12-06 at 11.49.52 AM](Screenshot%202024-12-06%20at%2011.49.52%20AM.png)


همچنین با بررسی نمودارهای مصرف منابع، می‌بینیم که در نقطه‌ای که افزایش ناگهانی مصرف داریم، تابع `temp` در حال اجرا بوده است:

![Screenshot 2024-12-06 at 11.50.40 AM](Screenshot%202024-12-06%20at%2011.50.40%20AM.png)


دلیل این موضوع هم استفاده‌ی نابهینه از `ArrayList` در این تابع است که حافظه و پردازنده زیادی را هدر می‌دهد. با تبدیل آن به جمع معمولی و ذخیره نکردن مقادیر میانی می‌توان عملکرد را بهبود داد. در تصویر زیر می‌بینیم که پس از اعمال این تغییر دیگر **hot spot** ای نداریم.

![Screenshot 2024-12-06 at 11.55.11 AM](Screenshot%202024-12-06%20at%2011.55.11%20AM.png)
# بخش دوم: پیاده‌سازی یک قطعه کد دیگر (PrimeChecker) و بهینه‌سازی آن

در این بخش، ابتدا کد یک کلاس را پیاده‌سازی می‌کنیم که به ازای عدد ورودی، تعداد اعداد اولی که از آن کوچک‌تر هستند را پرینت می‌کند. در ابتدا، تابع `isPrime` در این کلاس برای بررسی اول بودن یک عدد، بخش‌پذیری آن به تمام اعداد کوچک‌تر از خودش را بررسی می‌کند، که روش بهینه‌ای نیست. با دادن یک ورودی بزرگ مانند 1000000 به این تابع، زمان اجرای طولانی‌ای خواهیم داشت و **hot spot** های زیر به وجود می‌آیند، که همانطور که مشاهده می‌شود تمام آن‌ها از خط ۲۳ کد در تابع `isPrime` نشات گرفته‌اند:

![Screenshot 2024-12-06 at 12.01.42 PM](Screenshot%202024-12-06%20at%2012.01.42%20PM.png)
![Screenshot 2024-12-06 at 12.01.46 PM](Screenshot%202024-12-06%20at%2012.01.46%20PM.png)

اما با تغییر کد این تابع به گونه‌ای که فقط تا حد جذر عدد را چک کند‌ می‌توانیم بهبود در عملکرد کد و حذف **hot spot** ها را مشاهده کنیم:

![Screenshot 2024-12-06 at 12.02.34 PM](Screenshot%202024-12-06%20at%2012.02.34%20PM.png)

مقایسه مصرف کلیه منابع در هر یک از این دو حالت نیز از قسمت **summary** قابل بررسی است. در تصویر اول که مربوط به قبل از بهبود عملکرد کد است، مصرف منابع و زمان کل اجرا بیشتر از تصویر دوم که مربوط به حالت بهینه است خواهد بود:

![Screenshot 2024-12-06 at 12.05.45 PM](Screenshot%202024-12-06%20at%2012.05.45%20PM.png)

![Screenshot 2024-12-06 at 12.03.03 PM](Screenshot%202024-12-06%20at%2012.03.03%20PM.png)


